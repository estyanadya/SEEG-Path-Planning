import time
import SimpleITK as sitk
import sitkUtils
import slicer

entriesNode = slicer.mrmlScene.GetFirstNodeByName("entries") # vtkMRMLMarkupsFiducialNode
targetsNode = slicer.mrmlScene.GetFirstNodeByName("MarkupsFiducial") # vtkMRMLMarkupsFiducialNode, Node generated by path planning module by Rachel Sparks
ventriclesNode = slicer.mrmlScene.GetFirstNodeByName("ventricles") # vtkMRMLLabelMapVolumeNode
vesselsNode = slicer.mrmlScene.GetFirstNodeByName("vessels") # vtkMRMLLabelMapVolumeNode
hippoNode = slicer.mrmlScene.GetFirstNodeByName("r_hippo") # vtkMRMLLabelMapVolumeNode
lengthThreshold = 60 # in mm

startTime = time.time()

"""
Implement the length threshold
"""
# Function to calculate distance between two points
def distance(point1, point2):
    return ((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2 + (point2[2] - point1[2])**2)**0.5

# Initialize vtkPoints to store all points
# entriesNode = slicer.mrmlScene.GetFirstNodeByName("Entry to Target Lines")
points = vtk.vtkPoints()
entries_num = entriesNode.GetNumberOfControlPoints()
targets_num = targetsNode.GetNumberOfControlPoints()

# Initialize vtkCellArray to store the lines
linesCellArray = vtk.vtkCellArray()

# Add all entry points to vtkPoints
for i in range(entries_num):
    coord = [0.0, 0.0, 0.0]
    entriesNode.GetNthControlPointPositionWorld(i, coord)
    points.InsertNextPoint(coord)

# Add all target points to vtkPoints
for i in range(targets_num):
    coord = [0.0, 0.0, 0.0]
    targetsNode.GetNthControlPointPositionWorld(i, coord)
    points.InsertNextPoint(coord)

# Create lines between each pair of entry and target points
for i in range(entries_num):
    for j in range(targets_num):
        coord_entry = [0.0, 0.0, 0.0]
        coord_target = [0.0, 0.0, 0.0]
        entriesNode.GetNthControlPointPositionWorld(i, coord_entry)
        targetsNode.GetNthControlPointPositionWorld(j, coord_target)
        line_length = distance(coord_entry, coord_target)
        if line_length < lengthThreshold:
            line = vtk.vtkLine()
            line.GetPointIds().SetId(0, i)  # entry point
            line.GetPointIds().SetId(1, entries_num + j)  # corresponding target point
            linesCellArray.InsertNextCell(line)

# Create vtkPolyData and set points and lines
linesPolyData = vtk.vtkPolyData()
linesPolyData.SetPoints(points)
linesPolyData.SetLines(linesCellArray)

# Create a vtkMRMLModelNode to store lines
linesModelNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLModelNode")
linesModelNode.SetName("Entry to Target Lines")
linesModelNode.SetAndObservePolyData(linesPolyData)

# Visusalize lines
linesModelDisplayNode = slicer.vtkMRMLModelDisplayNode()
# linesModelDisplayNode = linesModelNode.GetDisplayNode()
slicer.mrmlScene.AddNode(linesModelDisplayNode)
linesModelNode.SetAndObserveDisplayNodeID(linesModelDisplayNode.GetID())
linesModelDisplayNode.SetVisibility2D(True)  # Show model in 2D views (sagittal, coronal, transversal)
slicer.app.layoutManager().sliceWidget('Red').sliceLogic().FitSliceToAll()
slicer.app.layoutManager().sliceWidget('Yellow').sliceLogic().FitSliceToAll()
slicer.app.layoutManager().sliceWidget('Green').sliceLogic().FitSliceToAll()


"""
Implement Danielsson Distance Map
"""
ventriclesVolumeArray = slicer.util.arrayFromVolume(ventriclesNode)
ventriclesImage = sitk.GetImageFromArray(ventriclesVolumeArray)
distance_map_filter = sitk.DanielssonDistanceMapImageFilter()
output_image = distance_map_filter.Execute(ventriclesImage)
output_volume_array = sitk.GetArrayFromImage(output_image)
output_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLLabelMapVolumeNode", "output_distance_map")
slicer.util.updateVolumeFromArray(output_node, output_volume_array)


stopTime = time.time()
print(f"Processing completed in {stopTime-startTime:.2f} seconds")